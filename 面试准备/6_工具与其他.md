# 面试准备6 - 工具与其他

## 1、Webpack
### 核心概念
> 打包工具 ==> js文件

### 工作流程
> 加载 --> 编译 --> 输出

1. 读取配置文件，创建 Compiler 对象
2. 调用插件的apply方法挂载插件监听，从入口开始进行编译
3. 按照文件类型，根据相应的loader对模块进行编译，并在合适的时机触发对应的事件，调用plugin，再根据模块依赖查找，递归第三步
4. 将编译后的文件打包成一个个chunk，确定输出内容
5. 根据output，将文件写入指定的文件夹

### loader
> 以管道的形式，对webpack传入的字符串按照需求修改

特性：
* 按照配置相反的顺序链式执行
* 基于node,对文件的增删改查有较高的权限
* 可同步也可异步

### plugin
```
class Plugin{
  	// 注册插件时，会调用 apply 方法
  	// apply 方法接收 compiler 对象
  	// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作
  	apply(compiler){
  		// compilation 是监听每次编译循环
  		// 每次文件变化，都会生成新的 compilation 对象并触发该事件
    	compiler.plugin('compilation',function(compilation) {})
  	}
}
```

### 优化
* 无用代码消除 ==> UglifyJs
* 摇树优化(Tree-shaking): 消除那些引用了但未被使用的代码 ==> 语法的静态分析
* 代码分割 ==> SplitChunksPlugin
    * 按页面拆分
    * 按功能拆分
    * 按照文件修改频率拆分

### 编译性能优化
* 使用 dev-server / 模块热替换 (HMR) 提升开发体验；
* 缩小编译范围
    * 指定modules
    * includes/exclude: 指定搜索范围/排除不必要的搜索范围；
    * alias: 缓存目录，避免重复寻址；
    * noParse: 避免对非模块化文件的加载；
* babel-loader：使用cacheDirectory
* 多进程并发
    * webpack-parallel-uglify-plugin
    * HappyPack
* 第三方库模块缓存
    * DLLPlugin 和 DLLReferencePlugin 可以提前进行打包并缓存，避免每次都重新编译
* 使用分析:
    * Webpack Analyse / webpack-bundle-analyzer 对打包后的文件进行分析，寻找可优化的地方；
    * 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方；
* source-map:
    * 开发: cheap-module-eval-source-map；
    * 生产: hidden-source-map；

## 2、项目性能优化
### 编码优化 ==> 代码最佳实践
* 数据读取:
    * 尽量在局部作用域中进行 变量缓存；
    * 避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护；
* 循环：
    * 尽可能 减少循环次数
    * 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
    * 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；
* 条件流程性能: Map / Object > switch > if-else
* 减少 cookie 体积: 能有效减少每次请求的体积和响应时间；
* dom 优化:
    * 减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
    * 减少重绘与回流
    * 使用事件委托，避免大量的事件绑定
* css 优化:
    * 层级扁平
    * 使用 动画属性 实现动画
    * 使用 `<link>` 替代原生 @import
* html 优化:
    * 避免`<img src="" />`空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求
    * 图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；
    * 语义化标签 有利于 SEO 与浏览器的解析时间

### 页面基础优化
* 引入位置: css 文件<head>中引入， js 文件<body>底部引入；
* 减少请求 (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
* 减少文件体积:
    * 删除多余代码: tree-shaking / UglifyJs / code-spliting
    * 混淆 / 压缩代码，开启 gzip 压缩；
    * 多份编译文件按条件引入:
        * 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
        * 可以利用<script type="module"> / <script type="module">进行条件引入用
    * 动态 polyfill，只针对不支持的浏览器引入 polyfill；
* 图片优化:
    * 根据业务场景，与UI探讨选择 合适质量，合适尺寸；
    * 根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
    * 小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；
    * 合适场景下，使用 iconfont 或者 svg；
* 使用缓存:
    * 浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；
    * CDN缓存: 静态文件合理使用 CDN 缓存技术；
        * HTML 放于自己的服务器上；
        * 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
        * 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；
    * 服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
    * 数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；
    
### 首屏渲染优化
* css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；
* 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；
* 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；
* 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑；
    * 控制字体包的加载时机；
    * 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；
* 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存；
* 分清轻重缓急:
    * 重要的元素优先渲染；
    * 视窗内的元素优先渲染；
* 服务端渲染(SSR):
    * 减少首屏需要的数据量，剔除冗余数据和请求；
    * 控制好缓存，对数据/页面进行合理的缓存；
    * 页面的请求使用流的形式进行传递；
* 优化用户感知:
    * 利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
    * 尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
    * 动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
    * js 执行时间避免超过 100ms，超过的话就需要做:
        * 寻找可 缓存 的点；
        * 任务的 分割异步 或 web worker 执行；


